import { writeFileSync, mkdirSync, existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
export class FileSystemManager {
    outputDirectory;
    constructor(outputDirectory = './docs') {
        this.outputDirectory = outputDirectory;
    }
    async writeDocumentation(output) {
        const filePath = join(this.outputDirectory, output.filePath);
        // Ensure output directory exists
        this.ensureDirectoryExists(dirname(filePath));
        // Prepare content with metadata
        const content = this.prepareContentWithMetadata(output);
        // Write the file
        writeFileSync(filePath, content, 'utf-8');
    }
    async writeMultipleDocuments(outputs) {
        // Ensure base output directory exists
        this.ensureDirectoryExists(this.outputDirectory);
        // Write all documents
        for (const output of outputs) {
            await this.writeDocumentation(output);
        }
        // Create or update index file
        await this.createDocumentationIndex(outputs);
    }
    async updateDocumentation(output) {
        const filePath = join(this.outputDirectory, output.filePath);
        if (existsSync(filePath)) {
            // Read existing file and preserve custom content if any
            const existingContent = readFileSync(filePath, 'utf-8');
            const updatedContent = this.mergeWithExistingContent(existingContent, output);
            writeFileSync(filePath, updatedContent, 'utf-8');
        }
        else {
            // File doesn't exist, create new
            await this.writeDocumentation(output);
        }
    }
    async createDocumentationIndex(outputs) {
        const indexPath = join(this.outputDirectory, 'index.md');
        const content = this.buildDocumentationIndex(outputs);
        writeFileSync(indexPath, content, 'utf-8');
    }
    async createDirectoryStructure() {
        // Create main documentation directories
        const directories = [
            'api',
            'architecture',
            'guides',
            'assets',
            'diagrams'
        ];
        for (const dir of directories) {
            this.ensureDirectoryExists(join(this.outputDirectory, dir));
        }
    }
    async backupExistingDocumentation() {
        if (!existsSync(this.outputDirectory)) {
            return null;
        }
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupPath = `${this.outputDirectory}.backup.${timestamp}`;
        // Simple backup by renaming (in a real implementation, you'd copy recursively)
        try {
            // This would need a proper recursive copy implementation
            return backupPath;
        }
        catch (error) {
            return null;
        }
    }
    getDocumentationStats() {
        if (!existsSync(this.outputDirectory)) {
            return {
                totalFiles: 0,
                totalSize: 0,
                lastModified: null
            };
        }
        // This would need recursive directory scanning
        // Simplified implementation for now
        return {
            totalFiles: 0,
            totalSize: 0,
            lastModified: new Date()
        };
    }
    ensureDirectoryExists(dirPath) {
        if (!existsSync(dirPath)) {
            mkdirSync(dirPath, { recursive: true });
        }
    }
    prepareContentWithMetadata(output) {
        const lines = [];
        // Add generated metadata header
        lines.push('<!---');
        lines.push('This file was automatically generated by Mastro CLI');
        lines.push(`Generated on: ${new Date().toISOString()}`);
        lines.push(`Document type: ${output.type}`);
        lines.push(`Title: ${output.title}`);
        if (output.references && output.references.length > 0) {
            lines.push(`References: ${output.references.join(', ')}`);
        }
        lines.push('');
        lines.push('To prevent this file from being overwritten, add custom content');
        lines.push('between the CUSTOM_START and CUSTOM_END markers below.');
        lines.push('--->');
        lines.push('');
        // Add the main content
        lines.push(output.content);
        // Add footer
        lines.push('');
        lines.push('---');
        lines.push('');
        lines.push('<!-- CUSTOM_START -->');
        lines.push('<!-- Add your custom content here - it will be preserved during regeneration -->');
        lines.push('<!-- CUSTOM_END -->');
        lines.push('');
        lines.push(`*Documentation generated by [Mastro CLI](https://github.com/your-org/mastro) on ${new Date().toLocaleDateString()}*`);
        return lines.join('\n');
    }
    mergeWithExistingContent(existingContent, newOutput) {
        // Extract custom content from existing file
        const customStartMarker = '<!-- CUSTOM_START -->';
        const customEndMarker = '<!-- CUSTOM_END -->';
        const customStartIndex = existingContent.indexOf(customStartMarker);
        const customEndIndex = existingContent.indexOf(customEndMarker);
        let customContent = '';
        if (customStartIndex !== -1 && customEndIndex !== -1) {
            customContent = existingContent.substring(customStartIndex + customStartMarker.length, customEndIndex).trim();
        }
        // Generate new content with preserved custom content
        const newContent = this.prepareContentWithMetadata(newOutput);
        if (customContent) {
            // Replace the placeholder custom content with the preserved content
            const placeholder = '<!-- Add your custom content here - it will be preserved during regeneration -->';
            return newContent.replace(placeholder, customContent);
        }
        return newContent;
    }
    buildDocumentationIndex(outputs) {
        const lines = [];
        lines.push('# Project Documentation Index');
        lines.push('');
        lines.push(`Generated on ${new Date().toLocaleDateString()} by Mastro CLI`);
        lines.push('');
        lines.push('## Available Documentation');
        lines.push('');
        // Group documents by type
        const groupedDocs = this.groupDocumentsByType(outputs);
        for (const [type, docs] of Object.entries(groupedDocs)) {
            lines.push(`### ${this.capitalizeFirstLetter(type)} Documentation`);
            lines.push('');
            for (const doc of docs) {
                const icon = this.getDocumentTypeIcon(doc.type);
                const size = this.estimateDocumentSize(doc);
                lines.push(`${icon} **[${doc.title}](${doc.filePath})** *(${size})*`);
                if (doc.sections && doc.sections.length > 0) {
                    lines.push(`   - ${doc.sections.length} sections`);
                }
                if (doc.diagrams && doc.diagrams.length > 0) {
                    lines.push(`   - ${doc.diagrams.length} diagrams`);
                }
                lines.push('');
            }
        }
        lines.push('## Quick Navigation');
        lines.push('');
        lines.push('| Document Type | Primary Use | Audience |');
        lines.push('|---------------|-------------|----------|');
        lines.push('| API Documentation | Reference for developers | Technical |');
        lines.push('| Architecture | System design understanding | Technical/Leadership |');
        lines.push('| User Guide | Getting started and tutorials | All users |');
        lines.push('| README | Project overview | All users |');
        lines.push('');
        lines.push('## Document Statistics');
        lines.push('');
        lines.push(`- **Total Documents**: ${outputs.length}`);
        lines.push(`- **Total Sections**: ${outputs.reduce((sum, doc) => sum + (doc.sections?.length || 0), 0)}`);
        lines.push(`- **Total Diagrams**: ${outputs.reduce((sum, doc) => sum + (doc.diagrams?.length || 0), 0)}`);
        lines.push(`- **Last Updated**: ${new Date().toLocaleString()}`);
        lines.push('');
        lines.push('## Maintenance');
        lines.push('');
        lines.push('This documentation is automatically generated. To regenerate:');
        lines.push('');
        lines.push('```bash');
        lines.push('# Regenerate all documentation');
        lines.push('mastro docs generate');
        lines.push('');
        lines.push('# Regenerate specific type');
        lines.push('mastro docs api');
        lines.push('mastro docs architecture');
        lines.push('mastro docs user-guide');
        lines.push('```');
        lines.push('');
        lines.push('---');
        lines.push(`*Index generated by [Mastro CLI](https://github.com/your-org/mastro)*`);
        return lines.join('\n');
    }
    groupDocumentsByType(outputs) {
        const grouped = {};
        for (const output of outputs) {
            if (!grouped[output.type]) {
                grouped[output.type] = [];
            }
            grouped[output.type].push(output);
        }
        return grouped;
    }
    capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    getDocumentTypeIcon(type) {
        const icons = {
            'api': 'üì°',
            'architecture': 'üèóÔ∏è',
            'user-guide': 'üìñ',
            'readme': 'üìã',
            'component': 'üß©',
            'deployment': 'üöÄ'
        };
        return icons[type] || 'üìÑ';
    }
    estimateDocumentSize(doc) {
        const contentLength = doc.content.length;
        if (contentLength < 1000)
            return 'Small';
        if (contentLength < 5000)
            return 'Medium';
        if (contentLength < 15000)
            return 'Large';
        return 'Very Large';
    }
    // Utility methods for file operations
    async writeAssets(diagrams) {
        const assetsDir = join(this.outputDirectory, 'assets');
        this.ensureDirectoryExists(assetsDir);
        // Write diagram files or other assets
        for (const diagram of diagrams) {
            if (diagram.type === 'mermaid') {
                const diagramPath = join(assetsDir, `${diagram.title.toLowerCase().replace(/\\s+/g, '-')}.md`);
                const content = `# ${diagram.title}\n\n${diagram.description}\n\n\`\`\`mermaid\n${diagram.content}\n\`\`\`\n`;
                writeFileSync(diagramPath, content, 'utf-8');
            }
        }
    }
    async createTemplateFiles() {
        const templatesDir = join(this.outputDirectory, 'templates');
        this.ensureDirectoryExists(templatesDir);
        // Create template files for customization
        const templates = {
            'custom-api.md': '# Custom API Documentation Template\n\nAdd your custom API documentation here.',
            'custom-guide.md': '# Custom User Guide Template\n\nAdd your custom user guide content here.',
            'CONTRIBUTING.md': '# Contributing Guidelines\n\nGuidelines for contributing to this project.'
        };
        for (const [filename, content] of Object.entries(templates)) {
            const filePath = join(templatesDir, filename);
            if (!existsSync(filePath)) {
                writeFileSync(filePath, content, 'utf-8');
            }
        }
    }
    getOutputDirectory() {
        return this.outputDirectory;
    }
    setOutputDirectory(directory) {
        this.outputDirectory = directory;
    }
}
//# sourceMappingURL=file-manager.js.map