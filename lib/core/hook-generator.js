import { writeFile, chmod, readFile, access } from 'fs/promises';
import { resolve, join } from 'path';
import { existsSync } from 'fs';
/**
 * Generates and manages intelligent pre-commit hooks with AI-powered validation
 */
export class HookGenerator {
    config;
    gitHooksPath;
    constructor(config) {
        this.config = config;
        this.gitHooksPath = resolve(process.cwd(), '.git', 'hooks');
    }
    /**
     * Generate and install pre-commit hook with AI validation
     */
    async generatePreCommitHook(hookConfig) {
        const hookPath = join(this.gitHooksPath, 'pre-commit');
        const hookContent = this.buildPreCommitHookContent(hookConfig);
        await writeFile(hookPath, hookContent, 'utf-8');
        await chmod(hookPath, '755'); // Make executable
        console.log(`‚úÖ Pre-commit hook installed at ${hookPath}`);
    }
    /**
     * Generate and install pre-push hook for additional validation
     */
    async generatePrePushHook(hookConfig) {
        const hookPath = join(this.gitHooksPath, 'pre-push');
        const hookContent = this.buildPrePushHookContent(hookConfig);
        await writeFile(hookPath, hookContent, 'utf-8');
        await chmod(hookPath, '755'); // Make executable
        console.log(`‚úÖ Pre-push hook installed at ${hookPath}`);
    }
    /**
     * Generate commit-msg hook for message validation
     */
    async generateCommitMsgHook(hookConfig) {
        const hookPath = join(this.gitHooksPath, 'commit-msg');
        const hookContent = this.buildCommitMsgHookContent(hookConfig);
        await writeFile(hookPath, hookContent, 'utf-8');
        await chmod(hookPath, '755'); // Make executable
        console.log(`‚úÖ Commit-msg hook installed at ${hookPath}`);
    }
    /**
     * Install comprehensive hook suite
     */
    async installHookSuite(hookConfig) {
        // Ensure .git/hooks directory exists
        try {
            await access(this.gitHooksPath);
        }
        catch (error) {
            throw new Error('Not in a git repository or .git/hooks directory not found');
        }
        console.log('üîß Installing intelligent pre-commit hook suite...');
        // Backup existing hooks
        await this.backupExistingHooks();
        // Generate all hooks
        await this.generatePreCommitHook(hookConfig);
        await this.generatePrePushHook(hookConfig);
        await this.generateCommitMsgHook(hookConfig);
        // Create configuration file
        await this.saveHookConfig(hookConfig);
        console.log('üéâ Hook suite installation complete!');
        console.log('');
        console.log('Your commits will now be validated with AI-powered analysis:');
        console.log(`  - Strictness: ${hookConfig.strictness}`);
        console.log(`  - Critical issue threshold: ${hookConfig.criticalThreshold}`);
        console.log(`  - Review persona: ${hookConfig.persona.name}`);
    }
    /**
     * Uninstall mastro hooks and restore backups
     */
    async uninstallHooks() {
        const hooks = ['pre-commit', 'pre-push', 'commit-msg'];
        for (const hook of hooks) {
            const hookPath = join(this.gitHooksPath, hook);
            const backupPath = join(this.gitHooksPath, `${hook}.mastro-backup`);
            try {
                // Remove mastro hook
                await access(hookPath);
                const content = await readFile(hookPath, 'utf-8');
                if (content.includes('# Generated by mastro')) {
                    console.log(`üóëÔ∏è Removing mastro ${hook} hook`);
                    // Restore backup if it exists
                    try {
                        await access(backupPath);
                        const backupContent = await readFile(backupPath, 'utf-8');
                        await writeFile(hookPath, backupContent, 'utf-8');
                        await chmod(hookPath, '755');
                        console.log(`‚úÖ Restored original ${hook} hook`);
                    }
                    catch {
                        // No backup, just remove the hook file
                        await writeFile(hookPath, '', 'utf-8'); // Create empty file
                        console.log(`‚úÖ Removed ${hook} hook`);
                    }
                }
            }
            catch (error) {
                // Hook doesn't exist, skip
            }
        }
        // Remove config file
        const configPath = join(this.gitHooksPath, '.mastro-hooks.json');
        try {
            await access(configPath);
            // Remove config file logic would go here
            console.log('üóëÔ∏è Removed hook configuration');
        }
        catch {
            // Config doesn't exist
        }
        console.log('‚úÖ Mastro hooks uninstalled successfully');
    }
    /**
     * Validate current hook configuration and suggest improvements
     */
    async validateHookSetup() {
        const startTime = Date.now();
        const result = {
            passed: true,
            criticalIssues: 0,
            highIssues: 0,
            mediumIssues: 0,
            lowIssues: 0,
            blockers: [],
            warnings: [],
            executionTime: 0,
            suggestions: []
        };
        // Check if hooks are installed
        const hooks = ['pre-commit', 'pre-push', 'commit-msg'];
        let installedHooks = 0;
        for (const hook of hooks) {
            const hookPath = join(this.gitHooksPath, hook);
            if (existsSync(hookPath)) {
                const content = await readFile(hookPath, 'utf-8');
                if (content.includes('# Generated by mastro')) {
                    installedHooks++;
                }
            }
        }
        if (installedHooks === 0) {
            result.passed = false;
            result.criticalIssues = 1;
            result.blockers.push('No mastro hooks installed');
            result.suggestions.push('Run `mastro hooks install` to set up intelligent pre-commit validation');
        }
        else if (installedHooks < 3) {
            result.warnings.push(`Only ${installedHooks}/3 hooks installed`);
            result.suggestions.push('Consider installing complete hook suite for full validation');
        }
        // Check hook configuration
        const configPath = join(this.gitHooksPath, '.mastro-hooks.json');
        try {
            await access(configPath);
            // Validate config file
            const config = JSON.parse(await readFile(configPath, 'utf-8'));
            if (config.strictness === 'lenient') {
                result.warnings.push('Hook strictness set to lenient - may miss important issues');
                result.suggestions.push('Consider using moderate or strict strictness for better code quality');
            }
            if (config.timeoutSeconds > 30) {
                result.warnings.push('Hook timeout is quite long - may slow down commits');
                result.suggestions.push('Consider reducing timeout for faster commit workflow');
            }
        }
        catch {
            result.warnings.push('No hook configuration found');
            result.suggestions.push('Hook configuration may need to be regenerated');
        }
        result.executionTime = Date.now() - startTime;
        return result;
    }
    // Private helper methods
    buildPreCommitHookContent(config) {
        return `#!/bin/bash
# Generated by mastro - Intelligent Pre-commit Hook
# Strictness: ${config.strictness}
# Critical threshold: ${config.criticalThreshold}
# Generated: ${new Date().toISOString()}

set -e

echo "üîç mastro: Analyzing staged changes..."

# Check if mastro is available
if ! command -v mastro &> /dev/null; then
    echo "‚ùå mastro not found in PATH"
    echo "Install mastro or add it to PATH to enable AI-powered validation"
    exit 1
fi

# Set timeout for the hook
timeout ${config.timeoutSeconds}s bash -c '
# Run mastro review on staged changes with specific persona
REVIEW_OUTPUT=$(mastro review --staged --format=json --persona=${config.persona.name} --strictness=${config.strictness} 2>/dev/null || echo "ERROR")

if [ "$REVIEW_OUTPUT" = "ERROR" ]; then
    echo "‚ö†Ô∏è mastro: Analysis failed, proceeding with commit"
    echo "Run \\"mastro review --staged\\" manually to check for issues"
    exit 0
fi

# Parse JSON output to check for critical issues
CRITICAL_COUNT=$(echo "$REVIEW_OUTPUT" | jq -r ".actionableItems | map(select(.priority == \\"critical\\")) | length" 2>/dev/null || echo "0")
HIGH_COUNT=$(echo "$REVIEW_OUTPUT" | jq -r ".actionableItems | map(select(.priority == \\"high\\")) | length" 2>/dev/null || echo "0")

# Convert to numbers (handle null/empty)
CRITICAL_COUNT=\${CRITICAL_COUNT:-0}
HIGH_COUNT=\${HIGH_COUNT:-0}

echo "üìä Found: \$CRITICAL_COUNT critical, \$HIGH_COUNT high priority issues"

# Block commit if critical issues exceed threshold
if [ "\$CRITICAL_COUNT" -gt ${config.criticalThreshold} ]; then
    echo ""
    echo "‚ùå Commit blocked: \$CRITICAL_COUNT critical issues found (threshold: ${config.criticalThreshold})"
    echo ""
    echo "Critical issues:"
    echo "$REVIEW_OUTPUT" | jq -r ".actionableItems[] | select(.priority == \\"critical\\") | \\"  - \(.title) (\(.file):\(.line // \\"N/A\\"))\\"" 2>/dev/null || echo "  Unable to parse critical issues"
    echo ""
    echo "üí° Fix these issues or use \\"git commit --no-verify\\" to bypass"
    exit 1
fi

# Warn about high priority issues
if [ "\$HIGH_COUNT" -gt ${config.highThreshold} ]; then
    echo ""
    echo "‚ö†Ô∏è  \$HIGH_COUNT high priority issues detected:"
    echo "$REVIEW_OUTPUT" | jq -r ".actionableItems[] | select(.priority == \\"high\\") | \\"  - \(.title)\\"" 2>/dev/null || echo "  Unable to parse high priority issues"
    echo ""
    
    # Interactive confirmation for high issues
    if [ -t 0 ]; then  # Check if running in terminal
        read -p "Continue with commit? [y/N] " -n 1 -r
        echo
        if [[ ! \$REPLY =~ ^[Yy]\$ ]]; then
            echo "Commit cancelled"
            exit 1
        fi
    else
        echo "Non-interactive mode: proceeding with commit"
    fi
fi

echo "‚úÖ mastro: Pre-commit validation passed"
' || {
    echo "‚è∞ mastro: Analysis timed out after ${config.timeoutSeconds}s"
    echo "üí° Consider increasing timeout or reducing changeset size"
    echo "Proceeding with commit..."
    exit 0
}

exit 0`;
    }
    buildPrePushHookContent(config) {
        return `#!/bin/bash
# Generated by mastro - Intelligent Pre-push Hook
# Generated: ${new Date().toISOString()}

echo "üöÄ mastro: Validating branch before push..."

# Check for any uncommitted changes that should be committed
UNCOMMITTED=\$(git status --porcelain)
if [ -n "\$UNCOMMITTED" ]; then
    echo "‚ö†Ô∏è Uncommitted changes detected:"
    echo "\$UNCOMMITTED"
    echo ""
    echo "üí° Consider committing or stashing changes before push"
    
    if [ -t 0 ]; then  # Interactive terminal
        read -p "Continue with push anyway? [y/N] " -n 1 -r
        echo
        if [[ ! \$REPLY =~ ^[Yy]\$ ]]; then
            echo "Push cancelled"
            exit 1
        fi
    fi
fi

# Run a comprehensive review of recent commits
echo "üîç Analyzing recent commits for quality issues..."

# Check last few commits on current branch
COMMIT_COUNT=\$(git rev-list --count HEAD ^origin/\$(git rev-parse --abbrev-ref HEAD) 2>/dev/null || echo "1")
COMMIT_COUNT=\${COMMIT_COUNT:-1}

if [ "\$COMMIT_COUNT" -gt 10 ]; then
    echo "‚ö†Ô∏è \$COMMIT_COUNT commits being pushed - consider smaller, more frequent pushes"
fi

echo "‚úÖ mastro: Pre-push validation completed"
exit 0`;
    }
    buildCommitMsgHookContent(config) {
        return `#!/bin/bash
# Generated by mastro - Intelligent Commit Message Hook
# Generated: ${new Date().toISOString()}

COMMIT_MSG_FILE=\$1
COMMIT_MSG=\$(cat "\$COMMIT_MSG_FILE")

# Skip merge commits and other special commits
if [[ \$COMMIT_MSG == Merge* ]] || [[ \$COMMIT_MSG == Revert* ]] || [[ \$COMMIT_MSG == fixup!* ]] || [[ \$COMMIT_MSG == squash!* ]]; then
    exit 0
fi

echo "üìù mastro: Validating commit message..."

# Basic commit message validation
if [ \${#COMMIT_MSG} -lt 10 ]; then
    echo "‚ùå Commit message too short (minimum 10 characters)"
    echo "Current: '\$COMMIT_MSG'"
    echo "üí° Use \\"mastro commit\\" for AI-generated messages"
    exit 1
fi

if [ \${#COMMIT_MSG} -gt 72 ]; then
    FIRST_LINE=\$(echo "\$COMMIT_MSG" | head -n1)
    if [ \${#FIRST_LINE} -gt 72 ]; then
        echo "‚ö†Ô∏è First line too long (\${#FIRST_LINE} chars, recommended: ‚â§72)"
        echo "üí° Consider shortening or use \\"mastro commit\\" for optimized messages"
    fi
fi

# Check for conventional commit format if team uses it
if echo "\$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .+"; then
    echo "‚úÖ Conventional commit format detected"
elif [ "${config.strictness}" = "strict" ]; then
    echo "‚ö†Ô∏è Consider using conventional commit format (feat:, fix:, docs:, etc.)"
    echo "üí° Use \\"mastro commit\\" for consistent formatting"
fi

echo "‚úÖ mastro: Commit message validation passed"
exit 0`;
    }
    async backupExistingHooks() {
        const hooks = ['pre-commit', 'pre-push', 'commit-msg'];
        for (const hook of hooks) {
            const hookPath = join(this.gitHooksPath, hook);
            const backupPath = join(this.gitHooksPath, `${hook}.mastro-backup`);
            try {
                await access(hookPath);
                const content = await readFile(hookPath, 'utf-8');
                // Only backup if it's not already a mastro hook
                if (!content.includes('# Generated by mastro')) {
                    await writeFile(backupPath, content, 'utf-8');
                    console.log(`üìã Backed up existing ${hook} hook`);
                }
            }
            catch (error) {
                // Hook doesn't exist, no need to backup
            }
        }
    }
    async saveHookConfig(config) {
        const configPath = join(this.gitHooksPath, '.mastro-hooks.json');
        const configData = {
            ...config,
            installedAt: new Date().toISOString(),
            version: '1.0.0'
        };
        await writeFile(configPath, JSON.stringify(configData, null, 2), 'utf-8');
    }
    /**
     * Get default hook configuration based on project type and team patterns
     */
    static getDefaultConfig(config) {
        // Determine strictness based on team patterns
        const strictness = 'moderate'; // Default to moderate strictness
        return {
            type: 'pre-commit',
            enabled: true,
            strictness,
            criticalThreshold: 0, // Block on any critical issue
            highThreshold: 3, // Warn on more than 3 high priority issues
            persona: {
                name: 'Pre-commit Reviewer',
                focus: ['maintainability', 'security', 'performance'],
                strictness: strictness,
                customRules: [
                    'Flag any obvious bugs or logic errors',
                    'Ensure proper error handling',
                    'Check for security vulnerabilities',
                    'Validate code follows team patterns'
                ]
            },
            customRules: [
                'Block commits with console.log in production code',
                'Require tests for new functionality',
                'Check for proper error handling'
            ],
            skipPatterns: [
                '*.md',
                '*.txt',
                '*.json',
                'docs/**',
                'examples/**'
            ],
            timeoutSeconds: 15 // Quick validation to avoid slowing down workflow
        };
    }
}
//# sourceMappingURL=hook-generator.js.map