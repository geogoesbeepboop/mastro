import {writeFileSync, mkdirSync, existsSync, readFileSync, statSync} from 'fs';
import {join, dirname, basename} from 'path';
import type {DocumentationOutput} from '../types/index.js';

export class FileSystemManager {
  private outputDirectory: string;

  constructor(outputDirectory: string = './docs') {
    this.outputDirectory = outputDirectory;
  }

  async writeDocumentation(output: DocumentationOutput): Promise<void> {
    const filePath = join(this.outputDirectory, output.filePath);
    
    // Ensure output directory exists
    this.ensureDirectoryExists(dirname(filePath));
    
    // Prepare content with metadata
    const content = this.prepareContentWithMetadata(output);
    
    // Write the file
    writeFileSync(filePath, content, 'utf-8');
  }

  async writeMultipleDocuments(outputs: DocumentationOutput[]): Promise<void> {
    // Ensure base output directory exists
    this.ensureDirectoryExists(this.outputDirectory);
    
    // Write all documents
    for (const output of outputs) {
      await this.writeDocumentation(output);
    }
    
    // Create or update index file
    await this.createDocumentationIndex(outputs);
  }

  async updateDocumentation(output: DocumentationOutput): Promise<void> {
    const filePath = join(this.outputDirectory, output.filePath);
    
    if (existsSync(filePath)) {
      // Read existing file and preserve custom content if any
      const existingContent = readFileSync(filePath, 'utf-8');
      const updatedContent = this.mergeWithExistingContent(existingContent, output);
      
      writeFileSync(filePath, updatedContent, 'utf-8');
    } else {
      // File doesn't exist, create new
      await this.writeDocumentation(output);
    }
  }

  async createDocumentationIndex(outputs: DocumentationOutput[]): Promise<void> {
    const indexPath = join(this.outputDirectory, 'index.md');
    const content = this.buildDocumentationIndex(outputs);
    
    writeFileSync(indexPath, content, 'utf-8');
  }

  async createDirectoryStructure(): Promise<void> {
    // Create main documentation directories
    const directories = [
      'api',
      'architecture',
      'guides',
      'assets',
      'diagrams'
    ];
    
    for (const dir of directories) {
      this.ensureDirectoryExists(join(this.outputDirectory, dir));
    }
  }

  async backupExistingDocumentation(): Promise<string | null> {
    if (!existsSync(this.outputDirectory)) {
      return null;
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = `${this.outputDirectory}.backup.${timestamp}`;
    
    // Simple backup by renaming (in a real implementation, you'd copy recursively)
    try {
      // This would need a proper recursive copy implementation
      return backupPath;
    } catch (error) {
      return null;
    }
  }

  getDocumentationStats(): {
    totalFiles: number;
    totalSize: number;
    lastModified: Date | null;
  } {
    if (!existsSync(this.outputDirectory)) {
      return {
        totalFiles: 0,
        totalSize: 0,
        lastModified: null
      };
    }
    
    // This would need recursive directory scanning
    // Simplified implementation for now
    return {
      totalFiles: 0,
      totalSize: 0,
      lastModified: new Date()
    };
  }

  private ensureDirectoryExists(dirPath: string): void {
    if (!existsSync(dirPath)) {
      mkdirSync(dirPath, { recursive: true });
    }
  }

  private prepareContentWithMetadata(output: DocumentationOutput): string {
    const lines: string[] = [];
    
    // Add generated metadata header
    lines.push('<!---');
    lines.push('This file was automatically generated by Mastro CLI');
    lines.push(`Generated on: ${new Date().toISOString()}`);
    lines.push(`Document type: ${output.type}`);
    lines.push(`Title: ${output.title}`);
    if (output.references && output.references.length > 0) {
      lines.push(`References: ${output.references.join(', ')}`);
    }
    lines.push('');
    lines.push('To prevent this file from being overwritten, add custom content');
    lines.push('between the CUSTOM_START and CUSTOM_END markers below.');
    lines.push('--->')
    lines.push('');
    
    // Add the main content
    lines.push(output.content);
    
    // Add footer
    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('<!-- CUSTOM_START -->');
    lines.push('<!-- Add your custom content here - it will be preserved during regeneration -->');
    lines.push('<!-- CUSTOM_END -->');
    lines.push('');
    lines.push(`*Documentation generated by [Mastro CLI](https://github.com/your-org/mastro) on ${new Date().toLocaleDateString()}*`);
    
    return lines.join('\n');
  }

  private mergeWithExistingContent(existingContent: string, newOutput: DocumentationOutput): string {
    // Extract custom content from existing file
    const customStartMarker = '<!-- CUSTOM_START -->';
    const customEndMarker = '<!-- CUSTOM_END -->';
    
    const customStartIndex = existingContent.indexOf(customStartMarker);
    const customEndIndex = existingContent.indexOf(customEndMarker);
    
    let customContent = '';
    if (customStartIndex !== -1 && customEndIndex !== -1) {
      customContent = existingContent.substring(
        customStartIndex + customStartMarker.length,
        customEndIndex
      ).trim();
    }
    
    // Generate new content with preserved custom content
    const newContent = this.prepareContentWithMetadata(newOutput);
    
    if (customContent) {
      // Replace the placeholder custom content with the preserved content
      const placeholder = '<!-- Add your custom content here - it will be preserved during regeneration -->';
      return newContent.replace(placeholder, customContent);
    }
    
    return newContent;
  }

  private buildDocumentationIndex(outputs: DocumentationOutput[]): string {
    const lines: string[] = [];
    
    lines.push('# Project Documentation Index');
    lines.push('');
    lines.push(`Generated on ${new Date().toLocaleDateString()} by Mastro CLI`);
    lines.push('');
    lines.push('## Available Documentation');
    lines.push('');
    
    // Group documents by type
    const groupedDocs = this.groupDocumentsByType(outputs);
    
    for (const [type, docs] of Object.entries(groupedDocs)) {
      lines.push(`### ${this.capitalizeFirstLetter(type)} Documentation`);
      lines.push('');
      
      for (const doc of docs) {
        const icon = this.getDocumentTypeIcon(doc.type);
        const size = this.estimateDocumentSize(doc);
        lines.push(`${icon} **[${doc.title}](${doc.filePath})** *(${size})*`);
        
        if (doc.sections && doc.sections.length > 0) {
          lines.push(`   - ${doc.sections.length} sections`);
        }
        
        if (doc.diagrams && doc.diagrams.length > 0) {
          lines.push(`   - ${doc.diagrams.length} diagrams`);
        }
        
        lines.push('');
      }
    }
    
    lines.push('## Quick Navigation');
    lines.push('');
    lines.push('| Document Type | Primary Use | Audience |');
    lines.push('|---------------|-------------|----------|');
    lines.push('| API Documentation | Reference for developers | Technical |');
    lines.push('| Architecture | System design understanding | Technical/Leadership |');
    lines.push('| User Guide | Getting started and tutorials | All users |');
    lines.push('| README | Project overview | All users |');
    lines.push('');
    
    lines.push('## Document Statistics');
    lines.push('');
    lines.push(`- **Total Documents**: ${outputs.length}`);
    lines.push(`- **Total Sections**: ${outputs.reduce((sum, doc) => sum + (doc.sections?.length || 0), 0)}`);
    lines.push(`- **Total Diagrams**: ${outputs.reduce((sum, doc) => sum + (doc.diagrams?.length || 0), 0)}`);
    lines.push(`- **Last Updated**: ${new Date().toLocaleString()}`);
    lines.push('');
    
    lines.push('## Maintenance');
    lines.push('');
    lines.push('This documentation is automatically generated. To regenerate:');
    lines.push('');
    lines.push('```bash');
    lines.push('# Regenerate all documentation');
    lines.push('mastro docs generate');
    lines.push('');
    lines.push('# Regenerate specific type');
    lines.push('mastro docs api');
    lines.push('mastro docs architecture');
    lines.push('mastro docs user-guide');
    lines.push('```');
    lines.push('');
    
    lines.push('---');
    lines.push(`*Index generated by [Mastro CLI](https://github.com/your-org/mastro)*`);
    
    return lines.join('\n');
  }

  private groupDocumentsByType(outputs: DocumentationOutput[]): Record<string, DocumentationOutput[]> {
    const grouped: Record<string, DocumentationOutput[]> = {};
    
    for (const output of outputs) {
      if (!grouped[output.type]) {
        grouped[output.type] = [];
      }
      grouped[output.type].push(output);
    }
    
    return grouped;
  }

  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private getDocumentTypeIcon(type: string): string {
    const icons: Record<string, string> = {
      'api': 'üì°',
      'architecture': 'üèóÔ∏è',
      'user-guide': 'üìñ',
      'readme': 'üìã',
      'component': 'üß©',
      'deployment': 'üöÄ'
    };
    
    return icons[type] || 'üìÑ';
  }

  private estimateDocumentSize(doc: DocumentationOutput): string {
    const contentLength = doc.content.length;
    
    if (contentLength < 1000) return 'Small';
    if (contentLength < 5000) return 'Medium';
    if (contentLength < 15000) return 'Large';
    return 'Very Large';
  }

  // Utility methods for file operations
  async writeAssets(diagrams: any[]): Promise<void> {
    const assetsDir = join(this.outputDirectory, 'assets');
    this.ensureDirectoryExists(assetsDir);
    
    // Write diagram files or other assets
    for (const diagram of diagrams) {
      if (diagram.type === 'mermaid') {
        const diagramPath = join(assetsDir, `${diagram.title.toLowerCase().replace(/\\s+/g, '-')}.md`);
        const content = `# ${diagram.title}\n\n${diagram.description}\n\n\`\`\`mermaid\n${diagram.content}\n\`\`\`\n`;
        writeFileSync(diagramPath, content, 'utf-8');
      }
    }
  }

  async createTemplateFiles(): Promise<void> {
    const templatesDir = join(this.outputDirectory, 'templates');
    this.ensureDirectoryExists(templatesDir);
    
    // Create template files for customization
    const templates = {
      'custom-api.md': '# Custom API Documentation Template\n\nAdd your custom API documentation here.',
      'custom-guide.md': '# Custom User Guide Template\n\nAdd your custom user guide content here.',
      'CONTRIBUTING.md': '# Contributing Guidelines\n\nGuidelines for contributing to this project.'
    };
    
    for (const [filename, content] of Object.entries(templates)) {
      const filePath = join(templatesDir, filename);
      if (!existsSync(filePath)) {
        writeFileSync(filePath, content, 'utf-8');
      }
    }
  }

  getOutputDirectory(): string {
    return this.outputDirectory;
  }

  setOutputDirectory(directory: string): void {
    this.outputDirectory = directory;
  }

  // Methods needed by AutoDocumentationUpdater
  async documentExists(docType: string): Promise<boolean> {
    const filePath = this.getDocumentPath(docType);
    return existsSync(filePath);
  }

  async readExistingDocument(docType: string): Promise<string | null> {
    const filePath = this.getDocumentPath(docType);
    
    if (!existsSync(filePath)) {
      return null;
    }
    
    try {
      return readFileSync(filePath, 'utf-8');
    } catch (error) {
      return null;
    }
  }

  private getDocumentPath(docType: string): string {
    const fileNames: Record<string, string> = {
      'api': 'api.md',
      'architecture': 'architecture.md',
      'user-guide': 'user-guide.md',
      'readme': 'README.md',
      'component': 'components.md',
      'deployment': 'deployment.md',
      'troubleshooting': 'TROUBLESHOOTING.md',
      'changelog': 'CHANGELOG.md',
      'contributing': 'CONTRIBUTING.md',
      'security': 'SECURITY.md',
      'performance': 'PERFORMANCE.md',
      'testing': 'TESTING.md'
    };
    
    const fileName = fileNames[docType] || `${docType}.md`;
    return join(this.outputDirectory, fileName);
  }
}